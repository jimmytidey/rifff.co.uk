package {	import fl.controls.TextInput;	import flash.events.*;	import flash.display.*;	import flash.text.TextField;	import fl.controls.Button;	import flash.media.SoundMixer;	import flash.media.SoundChannel;	public class PlayBack extends MovieClip{				public var step_time:Number; //indicates the length of time each step plays for 		public var step_number:int = 0; //indicates which step the timer is currently on		public var reload_sounds:int = 1; ////use this to check if we need to recreate all the sound objects		public var play_status:int = 0;		public var jsonData:Object;		public var grid:Object;		public var soundContainer:Object;		public var volumeArray:Array;		//other useful objects 		var myTimer:AccurateTimer = new AccurateTimer(0, 1000);			var render:Render = new Render();				function PlayBack(jsonData, volumeArray, scrubberContainer, soundContainer, grid_top, grid_left) {			render.drawPlayhead(jsonData, scrubberContainer, 0,  grid_top, grid_left);			this.jsonData = jsonData;			this.soundContainer = soundContainer;			this.volumeArray = volumeArray;;		}				public function go(jsonData, volumeArray, grid, soundContainer) {			this.grid = grid;			this.volumeArray = volumeArray;			calculateStepTime();			SoundMixer.stopAll(); // stop it from playing two things at once			myTimer.start();			play_status = 1;			playStep(true);		}				public function calculateStepTime() {			var beats_per_second:Number = jsonData['project_info']['bpm']/60;			var seconds_per_beat:Number = 1/beats_per_second; 			step_time = (seconds_per_beat * jsonData['project_info']['bpl'])*1000; 			myTimer = new AccurateTimer(step_time, 1000);			myTimer.addEventListener(TimerEvent.TIMER, step);		}						public function step(event:TimerEvent){			step_number++;			playStep(false);		}									public function my_stop() {			play_status = 0; 			myTimer.stop();			SoundMixer.stopAll();		}				public function movePlayHead(position) {			step_number = position;			render.movePlayhead(step_number);		}				public function playStep(first_played_step) { 			if (step_number == jsonData['project_info']['steps']) { //stop playback if we've got to the end of the track				 my_stop();				 transport.stopListener(); 			}						else {				render.movePlayhead(step_number);								for (var bank_index:int =0; bank_index < jsonData['banks'].length; bank_index++) {					for (var bank_option_index:int =0; bank_option_index < jsonData['banks'][bank_index]['bank_options'].length; bank_option_index++) {												var file_location = jsonData['banks'][bank_index]['bank_options'][bank_option_index]['file_location'];						file_location  = file_location.split(".");						var clean_file_location = file_location[0];												if (step_number > 0) {							previous_step = step_number-1;							//unusual runon situation							if (jsonData['banks'][bank_index]['bank_options'][bank_option_index]['loop'] == 'true' && grid[bank_index][step_number][bank_option_index] == 100 && grid[bank_index][previous_step][bank_option_index] == 100) {								//do nothing							}							//just treat things as normal 							else { 								if (jsonData['banks'][bank_index]['bank_options'][bank_option_index]['overplay'] == "false") {																		if (jsonData['banks'][bank_index]['bank_options'][bank_option_index]['sound'] is SoundChannel) { 										jsonData['banks'][bank_index]['bank_options'][bank_option_index]['sound'].stop();									}								}																			if (jsonData['banks'][bank_index]['bank_options'][bank_option_index]['overplay'] == "true") { 									//do nothing								}																//play any sounds which are set this time								if (grid[bank_index][step_number][bank_option_index] == 100) {									if (jsonData['banks'][bank_index]['bank_options'][bank_option_index]['loop'] == "true") {																				jsonData['banks'][bank_index]['bank_options'][bank_option_index]['sound'] = soundContainer[clean_file_location].play(0, 1000);									}									else { 										jsonData['banks'][bank_index]['bank_options'][bank_option_index]['sound'] = soundContainer[clean_file_location].play(0, 1);									}																		jsonData['banks'][bank_index]['bank_options'][bank_option_index]['sound'].soundTransform = volumeArray[bank_index][bank_option_index];								}							}							 							//checkbackwards to see if there should be something overplaying							if (jsonData['banks'][bank_index]['bank_options'][bank_option_index]['overplay'] == 'true' && first_played_step) {																if (soundContainer[clean_file_location]) {																		var lookback_step_number = soundContainer[clean_file_location].length / step_time;									for (var check_step = 0; check_step <=lookback_step_number; check_step++) { 										var test = step_number - check_step; 										if (test >= 0) {																						if( grid[bank_index][test][bank_option_index] == 100) { 												var time_ago = check_step*step_time; 												if (jsonData['banks'][bank_index]['bank_options'][bank_option_index]['loop']) {													jsonData['banks'][bank_index]['bank_options'][bank_option_index]['sound'] = soundContainer[clean_file_location].play(time_ago, 1000);												}												else { 													jsonData['banks'][bank_index]['bank_options'][bank_option_index]['sound'] = soundContainer[clean_file_location].play(time_ago);												}																								jsonData['banks'][bank_index]['bank_options'][bank_option_index]['sound'].soundTransform = volumeArray[bank_index][bank_option_index];											}										}									}								}							}						}												//this for the first step of the composition 						else {							//play any sounds which are set this time							if (grid[bank_index][step_number][bank_option_index] == 100) {																if(soundContainer[clean_file_location]) {									if (jsonData['banks'][bank_index]['bank_options'][bank_option_index]['loop']) { 										jsonData['banks'][bank_index]['bank_options'][bank_option_index]['sound'] = soundContainer[clean_file_location].play(0, 1000);									}									else { 										jsonData['banks'][bank_index]['bank_options'][bank_option_index]['sound'] = soundContainer[clean_file_location].play(0,1);									}																		jsonData['banks'][bank_index]['bank_options'][bank_option_index]['sound'].soundTransform = volumeArray[bank_index][bank_option_index];								}							}						}					}				}			}		}			}}